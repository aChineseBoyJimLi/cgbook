# 直线的绘制算法

**直线的绘制算法**

* 直线的扫描转换
* DDA 算法
* Bresenham 算法
* 中点坐标算法

## 1. 直线的扫描转换

**数学直线**：在数学上，理想的直线是一条没有宽度，由无穷多个无限小的连续的点组成。

**光栅平面显示的图像**：在光栅显示平面上，我们只能用二维光栅网格上尽可能靠近这条直线的象素集合来表示它。每个象素具有一定的尺寸，是显示平面上可被访问的最小单位，它的坐标x和y只能是整数，也就是说相邻象素的坐标值是阶跃的而不是连续的。

![数学上的直线](../asserts/直线的绘制/1.jpg)
![光栅上的直线](../asserts/直线的绘制/2.jpg)

直线的扫描转换算法就是利用直线的数学性质，通过直线方程，算出直线在栅格上每个点的坐标。

**缺点**：算法中涉及大量的浮点运算，效率不高；没有利用栅格显示的特性。

## 2. DDA 算法

DDA（digital differential analyzer ） 算法，采用了增量的方式，提高直线扫描转换的效率。在计算 Y<sub>x+1</sub> 时，只需要用到 Y<sub>x</sub> 的值。

### 2.1 基本思想

假设直线段的宽度为1,直线段的斜率: |k|<=1

已知过端点的直线段L：y=kx+B

直线斜率为：

$$k={y_1-y_0}\over {x_1-x_0}$$

计算：

$$
Y_{i+1} = kX_{i+1} + B
        = k(X_i+D_x)+B
        = kX_i + kD_x +B
        = Y_i + kD_x
$$
在栅格上，X 的增量 D<sub>x</sub> 的值都是1，所以

$$
Y_{i+1} = Y_i + k
$$

即：当x每递增1，y递增k，(即直线斜率)；取象素点(x, round(y))作为当前点的坐标。

![光栅上的直线](../asserts/直线的绘制/3.jpg)

### 2.2 算法实现

```
DDALine(int x0, int y0, int x1, int y1, int color)
{
    int x
    float dx,dy,k,y
    dx=x1-x0; dy=y1-y0;
    k=dy/dx;
    y=y0;
    for(x=x0;x<=x1;x++)
    {
        drawpixel(x,int(y+0.5),color);
        y=y+k;
    }
}
```

注：这里的 DDA 算法只实现了 |k|<=1 的情况，而 |k|>1 的直线只需要利用对称变换得到。

DDA 算法简单，实现容易，但y与k必须用浮点数表示，而且每一步都要对y进行四舍五入后取整，这使得它不利于硬件实现。

## 3. Bresenham 算法
